# 스프링 빈과 의존관계 - 자바 코드로 직접 스프링 빈 등록하기

---

## 스프링 빈을 등록하는 2가지 방법

* 컴포넌트 스캔과 자동 의존관계 설정
* **자바 코드로 직접 스프링 빈 등록하기**



기존에 작성했던 회원 서비스와 회원 리포지토리의 `@Service`, `@Controller`, `@Repository`, `@Autowired`를 삭제하고 진행한다.

* **hello.hellospring / SpringConfig.java**

```java
package hello.hellospring;

import hello.hellospring.repository.MemberRepository;
import hello.hellospring.repository.MemoryMemberRepository;
import hello.hellospring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SpringConfig {

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
}

```

자바 코드로 직접 스프링 빈을 등록하는 방법은 Configuration 파일을 생성해 정의를 직접해주는 방식이다.

우선 패키지 폴더 아래에 `SpringConfig` 자바 파일을 생성한 후, 클래스에 `@Configuration` 어노테이션을 작성해 이 파일은 Spring 설정 파일임을 명시한다.

> Controller는 따로 Config 파일에서 관리하기 어렵기 때문에 Component 스캔을 통한 방법으로 생성한다.

`@Configuration` 어노테이션은 Bean 객체들을 관리하는 역할이 주어진다. Spring Container에 Bean 객체를 등록하는 설정을 관리한다.

과거에는 XML 방식으로도 Configuration을 하는 방식도 있지만 최근에는 잘 사용하지 않는다.



### DI(Dependency Injection)의 3가지 방법

 DI(의존성 주입)에는 세 가지 방법이 존재한다.

1. 필드 주입
2. setter 주입
3. 생성자 주입

* 필드 주입

```java
package hello.hellospring.controller;

import hello.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class MemberController {
    @Autowired private MemberService memberService;
}

```

> 필드 주입은 권장하지 않는다. 왜냐하면 필드에서 바로 @Autowired를 통해 의존성 주입을 하게 되면 개발자가 변경하고 싶을 때 변경할 수 있는 방법이 존재하지 않는다.



* setter 주입

```java
package hello.hellospring.controller;

import hello.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class MemberController {

    private MemberService memberService;
    
    @Autowired
    public void setMemberService(MemberService memberService) {
        this.memberService = memberService;
    }
}

```

> setter injection 방식은 예전에 많이 사용됐었다. 하지만 이것의 단점은 어떤 사람이 Controller를 호출했을 때 MemberService는 public으로 열려있다. 이렇게 되면 수정이 자유롭다는 것인데 이는 치명적인 오류를 발생시킬 수도 있다.



* 생성자 주입

```java
package hello.hellospring.controller;

import hello.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class MemberController {
    // 다음과 같이 MemeberService 객체를 새로 생성해 쓸 수 있지만
    // Spring Container에서 관리할 수 있고 다른 Controller들도 MemberService를 사용할 수 있기 떄문에
    // 의존성 관리를 위해 Container에 등록을 해준다.
    //private final MemberService memberService = new MemberService();
    private final MemberService memberService;

    // Autowired 어노테이션은 Spring Container에 등록된 Bean 객체를 자동으로 연결해줌
    // 이것을 Dependency Injection (DI), 의존성 주입이라고 한다.
    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}
```



실무에서는 주로 정형화된 컨트롤러, 서비스, 레포지토리 같은 코드는 컴포넌트 스캔을 사용한다. 그리고 정형화 되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.